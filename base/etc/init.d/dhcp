#! /bin/sh
#
# Name: dhcp 
# Date: 2003-06-26 19:15
# Author: MontaVista Software, Inc. <source@mvista.com>
# Copyright: Copyright 1999-2003 MontaVista Software, Inc.
# License: 2003 (c) MontaVista Software, Inc. This file is licensed
#          under the terms of the GNU General Public License version 2.
#          This program is licensed "as is" without any warranty of any
#          kind, whether express or implied.
#
# Copyright 2002, 2003, 2004 Sony Corporation
# Copyright 2002, 2003, 2004 Matsushita Electric Industrial Co., Ltd.
#
### BEGIN INIT INFO
# Required-Start: 
# Required-Stop:
# Should-Start:
# Should-Stop:
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: Start or stop dhcpd daemon
# Description: Start or stop dhcpd daemon
### END INIT INFO 
# chkconfig: 2345 20 20

# Init script information
INIT_NAME=dhcp
DESC="dhcpd daemon"

# Individual Daemon information
DAEMON1=/usr/sbin/dhcpd
ARGS1=1000
BASENAME1=${DAEMON1##*/}
DHCPDPID=/var/run/dhcpd.pid

# Load init script configuration
[ -f /etc/default/$INIT_NAME ] && . /etc/default/$INIT_NAME

# Source the init script functions
. /etc/init.d/init-functions

# Verify daemons are installed
[ "$1" = "status" ] && NFOUND=4 || NFOUND=5
test -x $DAEMON1 || exit $NFOUND

# Set run_dhcpd to 1 to start dhcpd at boot or 0 to disable it.
run_dhcpd=0

if [ $run_dhcpd = 0 ]; then
        cat <<EOF

Please edit the file /etc/dhcpd.conf according to your needs. The current
/etc/dhcpd.conf is just the sample file that is provided with the DHCP
package from the Internet Software Consortium, so it will not be useful
at all for you.

After you have edited /etc/dhcpd.conf you will have to edit
/etc/init.d/dhcp as well. There you will have to set the variable
run_dhcpd to 1, and then type "/etc/init.d/dhcp start" to start the
dhcpd daemon.

EOF
fi

# Each init script action is defined below...

start() {
	local RET ERROR=

	log_status_msg "Starting $DESC: " -n
	log_status_msg "$BASENAME1" -n
	start_daemon $DAEMON1 $ARGS1
	RET=$?
	if [ $RET -eq 0 ]; then
		log_success_msg ". "
	else
		log_failure_msg " failed ($RET: $ERROR)."
		return 1
	fi
	
	log_status_msg ""
	return 0
}

stop () {
	local RET ERROR=

	log_status_msg "Stopping $DESC: " -n
	log_status_msg "$BASENAME1" -n
	killproc -p $DHCPPID $BASENAME1
	RET=$?
	if [ $RET -eq 0 ]; then
		log_success_msg ". "
	else
		log_failure_msg "failed ($RET: $ERROR). " -n
		return 1
	fi

	log_status_msg ""
	return 0
}

restart() {
	local RET

	log_status_msg "Restarting $DESC..."
	stop
		sleep 2
	start
	RET=$?

	return $RET
}

tryrestart() {
	local RET

	pidstatus $BASENAME
	RET=$?
	if [ $RET -eq 0 ]; then
		restart
		RET=$?
		else
		RET=7
	fi

	return $RET
}

#
# if the service does not support reload return code 3 should
# be the result...
#
reload() {
	local RET

	log_status_msg "Reloading $DESC configuration..." -n
	# killproc $BASENAME -HUP
	#
	# repeat as necessary...
	#
	log_success_msg "done."

	return 0
}

forcereload() {
	local RET

	reload
	RET=$?
	if [ $RET -ne 0 ]; then
		restart
		RET=$?
		fi
	
	return $RET
}

status() {
	local RET
	
	printstatus $BASENAME
	RET=$?

	return $RET
}

#
# Everything after this should be the same for all init scripts
#
# See the policy manual for information on actions and return codes.
#

parse() {
	case "$1" in
		start)
			start
			return $?
		;;
	stop)
			stop
			return $?
		;;
		restart)
			restart
			return $?
			;;
		try-restart)
			tryrestart
			return $?
			;;
		reload)
			reload
			return $?
			;;
		force-reload)
			forcereload
			return $?
			;;
		status)
			status
			return $?
		;;
	*)
			echo "Usage: $INIT_NAME " \
			"{start|stop|restart|try-restart|reload|" \
			"force-reload|status}" >&2
			;;
	esac
	
	return 1
}

parse $@

